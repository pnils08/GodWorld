/**
 * ============================================================================
 * EXPORT SCHEMA HEADERS
 * ============================================================================
 *
 * Mara's idea: Export all sheet headers to markdown for Claude Code visibility.
 *
 * SETUP (one-time):
 * 1. Go to Project Settings > Script Properties
 * 2. Add property: GITHUB_TOKEN = your_personal_access_token
 * 3. Token needs 'repo' scope (create at github.com/settings/tokens)
 *
 * USAGE:
 * - exportAndPushToGitHub() - Auto-push schema to GitHub (recommended)
 * - exportAllHeaders() - Just generate markdown (manual copy)
 *
 * ============================================================================
 */

var GITHUB_OWNER = 'pnils08';
var GITHUB_REPO = 'GodWorld';
var GITHUB_BRANCH = 'claude/migrate-scripts-github-RzAkz';
var SCHEMA_FILE_PATH = 'SCHEMA_HEADERS.md';

/**
 * Export headers and push directly to GitHub
 */
function exportAndPushToGitHub() {
  var token = PropertiesService.getScriptProperties().getProperty('GITHUB_TOKEN');

  if (!token) {
    throw new Error('GITHUB_TOKEN not set. Go to Project Settings > Script Properties and add it.');
  }

  // Generate the markdown
  var markdown = exportAllHeaders();

  // GitHub API URL
  var url = 'https://api.github.com/repos/' + GITHUB_OWNER + '/' + GITHUB_REPO + '/contents/' + SCHEMA_FILE_PATH;

  // Check if file exists (need SHA for updates)
  var sha = null;
  try {
    var getResponse = UrlFetchApp.fetch(url + '?ref=' + GITHUB_BRANCH, {
      method: 'GET',
      headers: {
        'Authorization': 'token ' + token,
        'Accept': 'application/vnd.github.v3+json'
      },
      muteHttpExceptions: true
    });

    if (getResponse.getResponseCode() === 200) {
      var existing = JSON.parse(getResponse.getContentText());
      sha = existing.sha;
      Logger.log('File exists, will update (SHA: ' + sha + ')');
    } else {
      Logger.log('File does not exist, will create new');
    }
  } catch (e) {
    Logger.log('Could not check existing file: ' + e.message);
  }

  // Prepare the payload
  var payload = {
    message: 'Update schema headers (' + new Date().toISOString().split('T')[0] + ')',
    content: Utilities.base64Encode(markdown),
    branch: GITHUB_BRANCH
  };

  if (sha) {
    payload.sha = sha;
  }

  // Push to GitHub
  var response = UrlFetchApp.fetch(url, {
    method: 'PUT',
    headers: {
      'Authorization': 'token ' + token,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });

  var code = response.getResponseCode();
  var body = response.getContentText();

  if (code === 200 || code === 201) {
    var result = JSON.parse(body);
    Logger.log('SUCCESS! Schema pushed to GitHub');
    Logger.log('URL: ' + result.content.html_url);

    SpreadsheetApp.getUi().alert(
      'Schema Headers Pushed!',
      'File updated at:\n' + result.content.html_url,
      SpreadsheetApp.getUi().ButtonSet.OK
    );

    return result.content.html_url;
  } else {
    Logger.log('ERROR: ' + code + ' - ' + body);
    throw new Error('GitHub API error: ' + code + ' - ' + body);
  }
}

function exportAllHeaders() {
  var ss = openSimSpreadsheet_(); // v2.14: Use configured spreadsheet ID
  var sheets = ss.getSheets();

  var output = [];
  output.push('# GodWorld Schema Headers');
  output.push('');
  output.push('**Auto-generated by exportAllHeaders()**');
  output.push('');
  output.push('**Last Updated:** ' + new Date().toISOString().split('T')[0]);
  output.push('');
  output.push('---');
  output.push('');

  // Sort sheets alphabetically
  sheets.sort(function(a, b) {
    return a.getName().localeCompare(b.getName());
  });

  for (var i = 0; i < sheets.length; i++) {
    var sheet = sheets[i];
    var name = sheet.getName();

    // Skip hidden sheets or sheets starting with underscore
    if (sheet.isSheetHidden() || name.charAt(0) === '_') {
      continue;
    }

    var lastCol = sheet.getLastColumn();
    var rowCount = sheet.getLastRow();

    output.push('## ' + name);
    output.push('');
    output.push('- **Rows:** ' + rowCount);
    output.push('- **Columns:** ' + lastCol);
    output.push('');

    if (lastCol > 0) {
      var headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

      output.push('| Col | Header |');
      output.push('|-----|--------|');

      for (var c = 0; c < headers.length; c++) {
        var colLetter = columnToLetter_(c + 1);
        var header = headers[c] || '(empty)';
        output.push('| ' + colLetter + ' | ' + header + ' |');
      }
    } else {
      output.push('*(Empty sheet)*');
    }

    output.push('');
    output.push('---');
    output.push('');
  }

  var markdown = output.join('\n');

  // Log it (can copy from execution log)
  Logger.log(markdown);

  // Also show in a dialog for easy copying
  var html = HtmlService.createHtmlOutput(
    '<pre style="font-size:11px; max-height:500px; overflow:auto;">' +
    markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;') +
    '</pre>' +
    '<p><button onclick="google.script.host.close()">Close</button></p>'
  ).setWidth(600).setHeight(500);

  SpreadsheetApp.getUi().showModalDialog(html, 'Schema Headers - Copy This');

  return markdown;
}

/**
 * Export headers for a single sheet (useful for quick checks)
 */
function exportSingleSheetHeaders(sheetName) {
  var ss = openSimSpreadsheet_(); // v2.14: Use configured spreadsheet ID
  var sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    Logger.log('Sheet not found: ' + sheetName);
    return null;
  }

  var lastCol = sheet.getLastColumn();
  if (lastCol === 0) {
    Logger.log(sheetName + ': (empty)');
    return [];
  }

  var headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

  Logger.log('=== ' + sheetName + ' ===');
  for (var c = 0; c < headers.length; c++) {
    Logger.log(columnToLetter_(c + 1) + ': ' + (headers[c] || '(empty)'));
  }

  return headers;
}

/**
 * Helper: Convert column number to letter (1=A, 27=AA, etc.)
 */
function columnToLetter_(col) {
  var letter = '';
  while (col > 0) {
    var mod = (col - 1) % 26;
    letter = String.fromCharCode(65 + mod) + letter;
    col = Math.floor((col - 1) / 26);
  }
  return letter;
}
